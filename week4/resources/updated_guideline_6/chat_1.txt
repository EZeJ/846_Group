TOM: We need a proper relational schema. THIRD NORMAL FORM exists for a reason.
JERRY: THIRD NORMAL FORM is fine in theory, but in production those JOIN chains are a nightmare.
TOM: JOIN performance issues come from BAD INDEXING, not normalization.
JERRY: No, they come from you adding FOREIGN KEY constraints everywhere.
TOM: FOREIGN KEY constraints ensure DATA INTEGRITY.
JERRY: They also make INSERT and UPDATE operations slower.
TOM: Only if you don’t create proper INDEXES on the FOREIGN KEY columns.
JERRY: We’re building a high-throughput system, not a textbook example of SQL purity.
TOM: Without constraints, we’ll end up with orphaned rows and broken REFERENCES.
JERRY: The APPLICATION LAYER can enforce relationships.
TOM: APPLICATION LOGIC is not a substitute for DATABASE CONSTRAINTS.
JERRY: It is when every SELECT requires five JOIN operations just to render a dashboard.
TOM: That’s because you want denormalized tables with duplicated data.
JERRY: Denormalization is a performance strategy, not a crime.
TOM: It becomes a crime when UPDATE anomalies start corrupting data.
JERRY: That’s why we use TRANSACTIONS.
TOM: TRANSACTIONS don’t fix bad schema design.
JERRY: Neither does blindly applying THIRD NORMAL FORM.
TOM: It’s not blind. It prevents INSERT, UPDATE, and DELETE anomalies.
JERRY: And causes query planners to choke on overly complex JOIN trees.
TOM: QUERY PLANNERS exist to optimize JOINs.
JERRY: Not when you force them to JOIN six tables to get a user profile.
TOM: That’s because you split user data across multiple concerns, which is correct design.
JERRY: It’s over-engineered. A single USER_PROFILE table would be faster.
TOM: And full of NULL columns and duplicated address data.
JERRY: Storage is cheap. CPU time during SELECT isn’t.
TOM: Until you need consistent FOREIGN KEY enforcement across ten services.
JERRY: We use MICROSERVICES. Each service owns its data.
TOM: Then why are we even using a relational database if we’re ignoring RELATIONAL principles?
JERRY: Because SQL is still better than a DOCUMENT STORE for analytics.
TOM: Then treat it like SQL, not a KEY-VALUE store.
JERRY: I’m treating it like a system that needs to handle 10K REQUESTS PER SECOND.
TOM: That doesn’t justify removing PRIMARY KEY and FOREIGN KEY relationships.
JERRY: I never said remove PRIMARY KEY.
TOM: You literally proposed dropping FOREIGN KEY on ORDERS.USER_ID.
JERRY: Because the JOIN between ORDERS and USERS is killing performance.
TOM: That’s an INDEX issue, not a schema issue.
JERRY: No, it’s because we normalized USERS into five separate tables.
TOM: USER_CONTACT, USER_ADDRESS, USER_SETTINGS — those are distinct entities.
JERRY: They could still live in one table with optional columns.
TOM: That leads to sparse tables and wasted space.
JERRY: Space is not our bottleneck. QUERY LATENCY is.
TOM: Query latency comes from poor QUERY PLANS.
JERRY: Query plans get worse when you JOIN everything.
TOM: That’s what INDEXES are for.
JERRY: Indexes slow down WRITES.
TOM: This is a read-heavy system.
JERRY: It’s both read and write heavy.
TOM: Then we balance indexes, not remove CONSTRAINTS.
JERRY: Constraints are part of the write overhead.
TOM: They are also part of data correctness.
JERRY: Data correctness can be validated before INSERT.
TOM: That doesn’t protect against concurrent WRITE anomalies.
JERRY: That’s what TRANSACTION ISOLATION LEVELS are for.
TOM: You can’t rely on SERIALIZABLE everywhere.
JERRY: Then don’t rely on FOREIGN KEYS everywhere either.
TOM: So your plan is: fewer constraints, fewer JOINs, more duplicated data.
JERRY: My plan is: faster queries, simpler schema, app-enforced rules.
TOM: That’s how technical debt starts.
JERRY: That’s how systems scale.
