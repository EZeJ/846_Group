# Week 5 Feedback: [Topic Title]

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia

## 1. Counterexample Problems

### Problem G6: How Role Formatting Affects LLM Understanding? 

You will use the conversation transcript between TOM and JERRY, who are debating database schema design.

Their discussion includes many capitalized SQL terms (e.g., JOIN, FOREIGN KEY, SELECT), which makes this a challenging case for speaker tracking.

**Task Description:**  
Find the answer to the question: Who argues that performance problems are caused by indexing, and who argues they are caused by schema design choices? Quote the relevant statements.

**Starter Code:**  
Folder: ```week4/drafts/updated_guideline_6```

Where formatting in ```chat_0.txt``` is:

> Tom: USER_CONTACT, USER_ADDRESS, USER_SETTINGS — those are distinct entities.


Formatting in ```chat_1.txt``` is:

>TOM: USER_CONTACT, USER_ADDRESS, USER_SETTINGS — those are distinct entities.
---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 6: Capitalize role identifiers

**Prompt and Context:**  

1) **Baseline: without specific chat formatting.**

    **Prompt**: Who argues that performance problems are caused by indexing, and who argues they are caused by schema design choices? Quote the relevant statements. 
    
    **Context**: ```chat_0.txt```

    **Solution or Output generated by GitHub Copilot:** 

    Tom argues that performance problems are caused by indexing, while Jerry argues they are caused by schema design choices.

    Relevant quotes:

    Tom (indexing):
    - "JOIN performance issues come from BAD INDEXING, not normalization."
    - "Only if you don’t create proper INDEXES on the FOREIGN KEY columns."
    - "That’s what INDEXES are for."

    Jerry (schema design choices):
    - "No, they come from you adding FOREIGN KEY constraints everywhere."
    - "It is when every SELECT requires five JOIN operations just to render a dashboard."
    - "And causes query planners to choke on overly complex JOIN trees."
    - "Not when you force them to JOIN six tables to get a user profile."
    - "No, it’s because we normalized USERS into five separate tables."


2) **Using Capitalization of the roles:**

    **Prompt:** Who argues that performance problems are caused by indexing, and who argues they are caused by schema design choices? Quote the relevant statements.

    **Context:** ```chat_1.txt```

    **Solution or Output generated by GitHub Copilot:** 

    Tom argues that performance problems are caused by indexing, while Jerry argues they are caused by schema design choices.

    Relevant quotes:

    - Tom (indexing):  
        - "JOIN performance issues come from BAD INDEXING, not normalization."
        - "Only if you don’t create proper INDEXES on the FOREIGN KEY columns."
        - "That’s what INDEXES are for."
        - "That’s an INDEX issue, not a schema issue."

    - Jerry (schema design):  
        - "No, they come from you adding FOREIGN KEY constraints everywhere."
        - "It’s because we normalized USERS into five separate tables."
        - "Because the JOIN between ORDERS and USERS is killing performance."
        - "Query plans get worse when you JOIN everything."


As we can see, the capitalization didn't make the response better, therefore, there is a need to create another guideline.

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Updated Guideline 6: Use Structured and Standardized JSON Role Formatting for Multi-Speaker Content

**Description:**

When providing conversations, transcripts, interviews, chats, or debates to an LLM, clearly structure speaker roles using consistent, high-visibility formatting. Whenever the task depends on tracking viewpoints, responsibility, or technical reasoning, use structured role formatting such as JSON or tagged dialogue. 

**Prompt and Context:**  

**Prompt:** Who argues that performance problems are caused by indexing, and who argues they are caused by schema design choices? Quote the relevant statements.

**Context:** ```chat_2.txt``` with JSON formatting:

 ```{"role": "TOM", "text": "USER_CONTACT, USER_ADDRESS, USER_SETTINGS — those are distinct entities."}```


**Solution or Output generated by GitHub Copilot:**  
In the conversation:

- TOM argues that performance problems are caused by indexing:
  - "JOIN performance issues come from BAD INDEXING, not normalization."
  - "Only if you don’t create proper INDEXES on the FOREIGN KEY columns."
  - "That’s an INDEX issue, not a schema issue."
  - "That’s what INDEXES are for."
  - "Then we balance indexes, not remove CONSTRAINTS."

- JERRY argues that performance problems are caused by schema design choices:
  - "THIRD NORMAL FORM is fine in theory, but in production those JOIN chains are a nightmare."
  - "No, they come from you adding FOREIGN KEY constraints everywhere."
  - "It is when every SELECT requires five JOIN operations just to render a dashboard."
  - "And causes query planners to choke on overly complex JOIN trees."
  - "Not when you force them to JOIN six tables to get a user profile."
  - "Because the JOIN between ORDERS and USERS is killing performance."
  - "No, it’s because we normalized USERS into five separate tables."
  - "Query plans get worse when you JOIN everything."
  - "Indexes slow down WRITES."
  - "Constraints are part of the write overhead."

---