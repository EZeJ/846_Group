# Week 5 Feedback: When “Avoid Implementation Details” Produces Misleading API Summaries

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia

## 1. Counterexample Problems

### Problem A_1: Password Reset Token Verification Has a Hidden Security-Critical Branch

**Task Description:**
Write a **public-facing docstring** for `verify_reset_token(token: str) -> str` that is safe for developers to rely on.
The summary must clearly state:

* what is returned on success,
* what happens on invalid/expired tokens,
* the **security-critical behavior** (invalidating token after use),
* any important side effects (DB writes),
* possible exceptions.

**Starter Code:**

```python
# auth_reset.py
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Optional
import hmac
import hashlib
import base64

class InvalidTokenError(Exception):
    pass

class ExpiredTokenError(Exception):
    pass

@dataclass
class ResetRecord:
    user_id: str
    token_hash: str
    expires_at: datetime
    used_at: Optional[datetime] = None

# In-memory store for simplicity
RESET_DB: Dict[str, ResetRecord] = {}  # key = token_id (public id)

def _hash_token(raw: str) -> str:
    return hashlib.sha256(raw.encode("utf-8")).hexdigest()

def issue_reset_token(user_id: str, ttl_minutes: int = 15) -> str:
    token_id = base64.urlsafe_b64encode(hashlib.sha1(user_id.encode()).digest()).decode().rstrip("=")
    raw = f"{token_id}:{user_id}:{int(datetime.utcnow().timestamp())}"
    sig = hmac.new(b"secret", raw.encode(), hashlib.sha256).hexdigest()
    token = f"{raw}:{sig}"

    RESET_DB[token_id] = ResetRecord(
        user_id=user_id,
        token_hash=_hash_token(token),
        expires_at=datetime.utcnow() + timedelta(minutes=ttl_minutes),
        used_at=None
    )
    return token

def verify_reset_token(token: str) -> str:
    """
    TODO
    """
    parts = token.split(":")
    if len(parts) != 4:
        raise InvalidTokenError("Malformed token")

    token_id, user_id, ts, sig = parts
    raw = f"{token_id}:{user_id}:{ts}"
    expected_sig = hmac.new(b"secret", raw.encode(), hashlib.sha256).hexdigest()
    if not hmac.compare_digest(sig, expected_sig):
        raise InvalidTokenError("Bad signature")

    rec = RESET_DB.get(token_id)
    if not rec:
        raise InvalidTokenError("Unknown token")

    # Security-critical: one-time use enforced
    if rec.used_at is not None:
        raise InvalidTokenError("Token already used")

    if datetime.utcnow() > rec.expires_at:
        raise ExpiredTokenError("Token expired")

    # Side effect: mark token as used (DB write)
    rec.used_at = datetime.utcnow()
    RESET_DB[token_id] = rec

    return rec.user_id
```

---

## 2. Guidelines that didn't work for Problem A_1

#### Guideline 4: Document Purpose and Contract, Not Implementation.

**Prompt and Context:**

> “Write a short docstring summary for `verify_reset_token` focusing on the high-level purpose.
> Avoid implementation details such as hashing/HMAC and internal storage. Keep it to 1–2 sentences. All code in week5/resources/updated_guideline5/auth_reset.py”

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```text
Verifies a password reset token and returns the associated user ID if valid.
```

**Why this is not correct/optimal for this counterexample:**

* It **omits the security-critical behavior**: the token is **one-time use** and is invalidated after successful verification.
* It **hides side effects**: the function performs a **DB write** (`used_at` update).
* It **does not mention failure modes**: invalid vs expired vs already-used tokens raise different exceptions.
* For an auth-related API, this “purpose-only” summary can mislead callers into assuming verification is a pure check and that tokens can be reused (which is false and security-relevant).

---

## 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 4 (New): “Purpose + Security-Relevant Contract”
This guideline extends “purpose + contract” with mandatory security-relevant contract elements for auth/token code. Instead of a generic purpose-only summary, it requires explicitly stating one key security property, any side effects, and failure modes/exceptions, while still avoiding cryptographic implementation details.

**Prompt and Context:**

> “Write a docstring summary for `verify_reset_token` intended for a public authentication API.
> Rules:
>
> 1. If the function is security/auth related (token/auth/password/reset), the summary MUST include: (a) one key security property, (b) side effects if any, and (c) failure modes/raised exceptions.
> 2. Do not describe cryptographic internals, but do state externally observable behavior (one-time use, expiration).
>    Keep it 2–4 sentences.
 All code in week5/resources/updated_guideline5/auth_reset.py”

**Solution or Output generated by GitHub Copilot (correct/optimal):**

```text
Validates a password reset token and returns the corresponding user ID on success.
Tokens are one-time use: a successful verification marks the token as used (state change) and prevents reuse.
Raises InvalidTokenError for malformed/unknown/bad-signature/already-used tokens, and ExpiredTokenError when the token is past its expiry time.
```

---

### Problem B: File Deletion API Has Multiple Context-Dependent Failure Modes

**Task Description:**
Write a **public-facing docstring** for `delete_user_file(path: str) -> str` that is safe for developers to rely on.
The summary must clearly state:

* what is returned on success,
* what happens on various failure conditions,
* the **security requirement** (owner permission),
* all distinct exceptions and when they occur.

**Starter Code:**

```python
# file_ops.py
import os
from pathlib import Path

class DiskFullError(Exception):
    pass

class NetworkMountError(Exception):
    pass

def delete_user_file(path: str) -> str:
    """
    TODO
    """
    p = Path(path)
    
    # Check if file exists
    if not p.exists():
        raise FileNotFoundError(f"File not found: {path}")
    
    # Check ownership (simplified)
    if p.stat().st_uid != os.getuid():
        raise PermissionError(f"Not owner of file: {path}")
    
    # Check if on network mount
    if str(p).startswith("/mnt/network/"):
        try:
            # Attempt network operation
            p.unlink()
        except OSError:
            raise NetworkMountError(f"Network mount unavailable: {path}")
    else:
        try:
            p.unlink()
        except OSError as e:
            if "No space left" in str(e):
                raise DiskFullError(f"Disk full during cleanup: {path}")
            raise OSError(f"IO error deleting file: {path}")
    
    return path
```

---

### Guidelines that didn't work for Problem B

#### Guideline 2: Explicitly Constrain Summary Length

**Description:**
Request summaries under a specific word count (e.g., "Summarize in one sentence, maximum 15 words") or match a target format like "@brief [one-line description]". This assists in preventing unnecessary summaries such as error handling, which explicitly instructing to ignore this can hurt results.

**Reasoning:**
LLMs tend to generate verbose summaries that score poorly on BLEU metrics despite being semantically accurate [3]. The Ericsson study found that a simple "WordRestrict" prompt asking for <20 words performed as well as complex retrieval-augmented approaches while being far simpler to implement [5].

**Prompt and Context:**

> "Generate a @brief description in one sentence (max 15 words) for `delete_user_file`."

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```text
@brief Deletes a user-owned file at the given path and returns the path.
```

**Why this is not correct/optimal for this counterexample:**

* It **omits all failure modes**: the function can raise 5 distinct exceptions (`FileNotFoundError`, `PermissionError`, `DiskFullError`, `OSError`, `NetworkMountError`) — none are mentioned.
* It **hides conditional behavior**: network-mounted files have different error handling than local files.
* It **does not mention severity**: `PermissionError` (security) and `NetworkMountError` (environment) have different implications for callers.
* For an API with multiple context-dependent failures, this brevity-only summary misleads callers into assuming deletion is simple and always succeeds or fails uniformly.

---

### New and Updated Guidelines that worked for Problem B

#### Guideline 2 (Updated): Constrain Length — Use Short, Structured Fields with Tiered Errors

**Description:**
Request brevity, but require a minimal set of short, explicit fields so critical information can't be squeezed out by an aggressive word limit. For functions with multiple failure modes, use tiered error fields (`@errors_high`, `@errors_other`) to communicate priority without losing completeness.

**Reasoning:**
Strict single-line word limits work for simple helpers but fail when a function has multiple distinct, observable failure modes. Using compact tagged fields with per-field limits keeps outputs short while guaranteeing coverage of critical information.

**Prompt and Context:**

> "Write a docstring for `delete_user_file` using these tagged fields. Keep each field within its word limit.
> @brief (one sentence, max 12 words)
> @effects (max 10 words — short phrase or 'none')
> @errors_high (critical errors, max 8 words)
> @errors_other (other errors, max 10 words)
> @security (max 10 words)
> Output exactly these tags in the given order."

**Solution or Output generated by GitHub Copilot (correct/optimal):**

```text
@brief Deletes a user-owned file; returns path on success.
@effects Removes file from disk permanently.
@errors_high FileNotFoundError, PermissionError.
@errors_other DiskFullError, OSError, NetworkMountError.
@security Requires caller to be file owner.
```

**Why this is correct/optimal for this counterexample:**

* **Complete failure coverage**: all 5 exceptions are listed, grouped by severity.
* **Security requirement stated**: ownership check is explicit.
* **Still concise**: each field respects word limits for quick scanning.
* **Actionable**: callers know which errors to handle as critical vs. environmental.

### Problem C: Section-by-Section Summarization Fails on Cross-Section Invariants

**Task Description:**
Summarize a long function by dividing it into logical blocks. In this case, splitting leads the model to overlook an important rule that links early validation with the final commit logic.

**Starter Code:**

```python
from decimal import Decimal

def transfer(src, dst, amount: Decimal, ledger, txlog, limits):
    # Section 1: validate + derive authorization state
    if amount <= 0:
        raise ValueError("amount must be positive")
    if src.id == dst.id:
        raise ValueError("self-transfer forbidden")

    risk_flag = amount > limits.instant_threshold
    requires_2fa = risk_flag or src.is_new_device

    # soft reserve starts here and must be released on all exits
    hold_id = ledger.place_hold(src.id, amount)

    # Section 2: fraud + policy checks
    if ledger.daily_outgoing(src.id) + amount > limits.daily_cap:
        ledger.release_hold(hold_id)
        return {"ok": False, "reason": "daily_cap"}

    if requires_2fa and not src.session.has_2fa:
        ledger.release_hold(hold_id)
        return {"ok": False, "reason": "2fa_required"}

    # Section 3: commit + audit
    try:
        ledger.debit(src.id, amount)
        ledger.credit(dst.id, amount)
        tx_id = txlog.record(
            src=src.id, dst=dst.id, amount=str(amount), risk=risk_flag
        )
        ledger.release_hold(hold_id)
        return {"ok": True, "tx_id": tx_id, "risk": risk_flag}
    except Exception:
        ledger.release_hold(hold_id)
        raise
```

### Guidelines that didn't work for Problem C

#### Guideline 5: Break Large amounts of Code into Logical Sections

**Prompt and Context:**
_Split this function into logical sections and summarize each section separately in 1–2 lines._


**Solution or Output generated by GitHub Copilot (not correct/optimal):**
Here is the function split into logical sections with summaries for each:

1. **Validation and Authorization State Derivation**:
   - Validates the input (e.g., positive amount, no self-transfers).
   - Determines if the transaction requires additional security measures like 2FA based on risk factors.

2. **Fraud and Policy Checks**:
   - Ensures the transaction complies with daily limits and policies.
   - Handles cases where additional authentication is required, releasing the hold if checks fail.

3. **Transaction Commitment and Auditing**:
   - Executes the transaction by debiting and crediting the respective accounts.
   - Records the transaction in the log and releases the hold, ensuring proper cleanup even in case of errors.

**Why this output is not good?**

This output is clear, but it is not enough. It describes each section separately and overlooks important safety guarantees across sections. It fails to say that once a hold is in place, it must be released on every exit path—whether through success, rejection, or exception. It also downplays the need for consistency between early risk assessment and later audit logging. This may lead to false confidence and allow for unsafe changes.

### New and Updated Guidelines that worked for Problem C

#### Guideline 5 (Updated): Add a Cross-Section Invariant Pass After Chunked Summaries

**Description:**
It suggests dividing large code into logical sections and adding a final cross-section invariant pass. This final pass checks the relationships between sections, ensuring the summary includes important global rules like necessary cleanup steps, shared state assumptions, or values computed early and used later. In practice, the model first creates concise section summaries. Then, it clearly lists conditions that must remain true across all return and exception paths. This method keeps the summary clear and organized, while also improving correctness and lowering the risk of unsafe refactoring choices.

**Prompt and Context:**

**Prompt**
_First summarize each logical section. Then add a required ‘cross-section invariants’ block listing conditions/resources that must hold across all sections, including every return and exception path._

**Context**

week5/resources/updated_guideline5/problem_c.py

**Solution or Output generated by GitHub Copilot:** 

Read [](file:///Users/alinalytovchenko/Documents/Code/846_Group/week5/resources/updated_guideline5/problem_c.py)

### Summary of Logical Sections

1. **Section 1: Validate + Derive Authorization State**
   - Validates the input `amount` to ensure it is positive.
   - Prevents self-transfers by checking if `src.id` equals `dst.id`.
   - Determines if the transaction is risky (based on `amount` and `limits.instant_threshold`) or if two-factor authentication (2FA) is required.
   - Places a soft hold on the source account (`src`) for the transaction amount.

2. **Section 2: Fraud + Policy Checks**
   - Ensures the transaction does not exceed the daily outgoing limit (`limits.daily_cap`) for the source account.
   - Verifies if 2FA is required and whether the source session has 2FA enabled.
   - Releases the soft hold and exits early if any of these checks fail.

3. **Section 3: Commit + Audit**
   - Attempts to debit the source account and credit the destination account.
   - Records the transaction in the transaction log (`txlog`), including risk information.
   - Releases the soft hold and returns a success response if all operations succeed.
   - Ensures the soft hold is released even in the event of an exception, and re-raises the exception.

---

### Required `cross-section invariants` Block

I'll add a `cross-section invariants` block to ensure that conditions/resources are consistent across all sections, including every return and exception path. 

Using "Edit File"

Using ""


````

````
I have added a `cross-section invariants` block to document the conditions and resources that must hold across all sections, including every return and exception path. Let me know if further refinements are needed!

Made changes.

**Why this output is better?**

This output is better because it provides safety and clarity: the cross-section invariants capture important rules that must hold across success, early returns, and exceptions, and the section summaries clearly explain each block. The additional global check improves the summary's accuracy and helps avoid refactoring errors, particularly in the areas of state consistency and resource cleanup.

---

### Problem D: Over-constrained summaries miss concurrency contracts (RingBuffer)

**Task Description:**  
Generate Doxygen documentation for `ring_push` and `ring_pop` in a lock-free single-producer/single-consumer ring buffer. The docs must clearly state (1) thread-safety assumptions, (2) failure conditions, and (3) what the boolean return value means.

**Starter Code:**  
```c
// ring_buffer.h
#ifndef RING_BUFFER_H
#define RING_BUFFER_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdatomic.h>

typedef struct {
    uint8_t* buffer;
    size_t capacity;
    atomic_size_t head;  // Write position (producer)
    atomic_size_t tail;  // Read position (consumer)
} RingBuffer;

RingBuffer* ring_create(size_t capacity);
void ring_destroy(RingBuffer* rb);
bool ring_push(RingBuffer* rb, const void* data, size_t len);
bool ring_pop(RingBuffer* rb, void* data, size_t len);
size_t ring_size(const RingBuffer* rb);
size_t ring_free_space(const RingBuffer* rb);
bool ring_is_empty(const RingBuffer* rb);
bool ring_is_full(const RingBuffer* rb);

#endif
```

```c
// ring_buffer.c (excerpt)
bool ring_push(RingBuffer* rb, const void* data, size_t len) {
    if (!rb || !data || len == 0) return false;

    size_t head = atomic_load_explicit(&rb->head, memory_order_relaxed);
    size_t tail = atomic_load_explicit(&rb->tail, memory_order_acquire);

    size_t free = (tail - head - 1 + rb->capacity) % rb->capacity;
    if (len > free) return false;

    const uint8_t* src = (const uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        rb->buffer[(head + i) % rb->capacity] = src[i];
    }

    atomic_store_explicit(&rb->head, (head + len) % rb->capacity, memory_order_release);
    return true;
}

bool ring_pop(RingBuffer* rb, void* data, size_t len) {
    if (!rb || !data || len == 0) return false;

    size_t tail = atomic_load_explicit(&rb->tail, memory_order_relaxed);
    size_t head = atomic_load_explicit(&rb->head, memory_order_acquire);

    size_t available = (head - tail + rb->capacity) % rb->capacity;
    if (len > available) return false;

    uint8_t* dst = (uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        dst[i] = rb->buffer[(tail + i) % rb->capacity];
    }

    atomic_store_explicit(&rb->tail, (tail + len) % rb->capacity, memory_order_release);
    return true;
}
```

---

### 2. Guidelines that didn't work for Problem D

#### Guideline 2: Explicitly Constrain Summary Length
**Prompt and Context:**  
Context: Copilot CLI has access to the repository files.  
Prompt to Copilot:
> Add Doxygen comments for the C functions ring_push and ring_pop declared in CS-846-Code-Summarization-Excercise/C-C++/ring_buffer.h (see implementation in ring_buffer.c). Follow Guideline 2: write a single-sentence @brief (max 15 words) for each function, keep the rest minimal, and use only @brief, @param, and @return. Output ONLY the two comment blocks (ready to paste above the declarations).

**Solution or Output generated by GitHub Copilot:**  
```c
/**
 * @brief Push bytes into the ring buffer.
 * @param rb Pointer to the ring buffer.
 * @param data Pointer to source bytes to copy.
 * @param len Number of bytes to push.
 * @return true on success, false on failure.
 */

/**
 * @brief Pop bytes from the ring buffer.
 * @param rb Pointer to the ring buffer.
 * @param data Pointer to destination buffer for popped bytes.
 * @param len Number of bytes to pop.
 * @return true on success, false on failure.
 */
```

**Quick test (required items):**
- Thread-safety model (SPSC / not MPMC): **Missing**
- Failure conditions (`len > free/available`, NULL/len==0): **Missing**
- Atomic ordering / lock-free concurrency semantics: **Missing**

**Reasoning (why this guideline failed here):**
- The prompt *over-constrains content*: limiting output to only `@brief/@param/@return` and “keep the rest minimal” removes the place where concurrency contracts normally live (`@note`/thread-safety/ordering).
- For lock-free/SPSC code, “what it does” is insufficient—correct usage depends on assumptions (SPSC vs MPMC) and specific failure modes (insufficient space/data vs invalid args). The generated output collapses all of that into “false on failure,” which is ambiguous and not actionable.

---

### 3. New and Updated Guidelines that worked for Problem D

#### Updated Guideline 2: Constrain `@brief`, but require a “contract checklist” for concurrency/IO code
**New guideline (updated):**  
Constrain only the `@brief` line (e.g., ≤15 words) for readability, but do **not** cap the rest of the doc when the function has correctness-critical constraints. For concurrency/IO/memory-ownership code, require a short checklist section (e.g., `@note`) that explicitly states:
1) thread-safety assumptions (e.g., SPSC/MPMC, blocking),  
2) failure conditions and return-value meaning, and  
3) any required ordering/locking assumptions (e.g., acquire/release usage).

**Prompt and Context:**  
Context: Copilot CLI has access to the repository files.  
Prompt to Copilot:
> Add Doxygen comments for the C functions ring_push and ring_pop declared in CS-846-Code-Summarization-Excercise/C-C++/ring_buffer.h (see implementation in ring_buffer.c). Keep @brief to one sentence (max 15 words) for each function, but you MUST include a short @note checklist covering: (1) thread-safety assumptions: single-producer/single-consumer only (not safe for multiple producers/consumers), (2) when/why the function returns false (invalid args and insufficient free space/available data), and (3) that producer/consumer coordination uses C11 atomics with acquire/release ordering. Output ONLY the two comment blocks (ready to paste above the declarations).

**Solution or Output generated by GitHub Copilot:**  
```c
/**
 * @brief Push bytes into the ring buffer.
 *
 * @param rb Pointer to the RingBuffer.
 * @param data Pointer to source data to copy into the buffer.
 * @param len Number of bytes to push.
 * @return true on success, false on failure.
 *
 * @note Checklist:
 * - Thread-safety: single-producer/single-consumer only (not safe for multiple producers/consumers).
 * - Failure: returns false for invalid arguments or when insufficient free space exists.
 * - Synchronization: producer/consumer coordination uses C11 atomics (atomic_size_t) with acquire/release ordering.
 */

/**
 * @brief Pop bytes from the ring buffer.
 *
 * @param rb Pointer to the RingBuffer.
 * @param data Destination buffer where popped bytes are written.
 * @param len Number of bytes to pop.
 * @return true on success, false on failure.
 *
 * @note Checklist:
 * - Thread-safety: single-producer/single-consumer only (not safe for multiple producers/consumers).
 * - Failure: returns false for invalid arguments or when insufficient available data exists.
 * - Synchronization: producer/consumer coordination uses C11 atomics (atomic_size_t) with acquire/release ordering.
 */
```

**Quick test (same required items):**
- Thread-safety model (SPSC / not MPMC): **Present**
- Failure conditions (`len > free/available`, NULL/len==0): **Present**
- Atomic ordering / lock-free concurrency semantics: **Present**

**Reasoning (why the updated guideline/prompt is better):**
- It keeps readability (short `@brief`) while explicitly requiring the *missing* contract details needed to use the API correctly.
- The added checklist makes “false” actionable by tying it to concrete failure modes and clearly stating the SPSC assumption and acquire/release coordination.

