# Week 5 Feedback: When “Avoid Implementation Details” Produces Misleading API Summaries

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia

## 1. Counterexample Problems

### Problem A_1: Password Reset Token Verification Has a Hidden Security-Critical Branch

**Task Description:**
Write a **public-facing docstring** for `verify_reset_token(token: str) -> str` that is safe for developers to rely on.
The summary must clearly state:

* what is returned on success,
* what happens on invalid/expired tokens,
* the **security-critical behavior** (invalidating token after use),
* any important side effects (DB writes),
* possible exceptions.

**Starter Code:**

```python
# auth_reset.py
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Optional
import hmac
import hashlib
import base64

class InvalidTokenError(Exception):
    pass

class ExpiredTokenError(Exception):
    pass

@dataclass
class ResetRecord:
    user_id: str
    token_hash: str
    expires_at: datetime
    used_at: Optional[datetime] = None

# In-memory store for simplicity
RESET_DB: Dict[str, ResetRecord] = {}  # key = token_id (public id)

def _hash_token(raw: str) -> str:
    return hashlib.sha256(raw.encode("utf-8")).hexdigest()

def issue_reset_token(user_id: str, ttl_minutes: int = 15) -> str:
    token_id = base64.urlsafe_b64encode(hashlib.sha1(user_id.encode()).digest()).decode().rstrip("=")
    raw = f"{token_id}:{user_id}:{int(datetime.utcnow().timestamp())}"
    sig = hmac.new(b"secret", raw.encode(), hashlib.sha256).hexdigest()
    token = f"{raw}:{sig}"

    RESET_DB[token_id] = ResetRecord(
        user_id=user_id,
        token_hash=_hash_token(token),
        expires_at=datetime.utcnow() + timedelta(minutes=ttl_minutes),
        used_at=None
    )
    return token

def verify_reset_token(token: str) -> str:
    """
    TODO
    """
    parts = token.split(":")
    if len(parts) != 4:
        raise InvalidTokenError("Malformed token")

    token_id, user_id, ts, sig = parts
    raw = f"{token_id}:{user_id}:{ts}"
    expected_sig = hmac.new(b"secret", raw.encode(), hashlib.sha256).hexdigest()
    if not hmac.compare_digest(sig, expected_sig):
        raise InvalidTokenError("Bad signature")

    rec = RESET_DB.get(token_id)
    if not rec:
        raise InvalidTokenError("Unknown token")

    # Security-critical: one-time use enforced
    if rec.used_at is not None:
        raise InvalidTokenError("Token already used")

    if datetime.utcnow() > rec.expires_at:
        raise ExpiredTokenError("Token expired")

    # Side effect: mark token as used (DB write)
    rec.used_at = datetime.utcnow()
    RESET_DB[token_id] = rec

    return rec.user_id
```

---

## 2. Guidelines that didn't work for Problem A_1

#### Guideline 4: Document Purpose and Contract, Not Implementation.

**Prompt and Context:**

> “Write a short docstring summary for `verify_reset_token` focusing on the high-level purpose.
> Avoid implementation details such as hashing/HMAC and internal storage. Keep it to 1–2 sentences. All code in week5/resources/updated_guideline5/auth_reset.py”

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```text
Verifies a password reset token and returns the associated user ID if valid.
```

**Why this is not correct/optimal for this counterexample:**

* It **omits the security-critical behavior**: the token is **one-time use** and is invalidated after successful verification.
* It **hides side effects**: the function performs a **DB write** (`used_at` update).
* It **does not mention failure modes**: invalid vs expired vs already-used tokens raise different exceptions.
* For an auth-related API, this “purpose-only” summary can mislead callers into assuming verification is a pure check and that tokens can be reused (which is false and security-relevant).

---

## 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 1 (New): “Purpose + Security-Relevant Contract”
This guideline extends “purpose + contract” with mandatory security-relevant contract elements for auth/token code. Instead of a generic purpose-only summary, it requires explicitly stating one key security property, any side effects, and failure modes/exceptions, while still avoiding cryptographic implementation details.

**Prompt and Context:**

> “Write a docstring summary for `verify_reset_token` intended for a public authentication API.
> Rules:
>
> 1. If the function is security/auth related (token/auth/password/reset), the summary MUST include: (a) one key security property, (b) side effects if any, and (c) failure modes/raised exceptions.
> 2. Do not describe cryptographic internals, but do state externally observable behavior (one-time use, expiration).
>    Keep it 2–4 sentences.
 All code in week5/resources/updated_guideline5/auth_reset.py”

**Solution or Output generated by GitHub Copilot (correct/optimal):**

```text
Validates a password reset token and returns the corresponding user ID on success.
Tokens are one-time use: a successful verification marks the token as used (state change) and prevents reuse.
Raises InvalidTokenError for malformed/unknown/bad-signature/already-used tokens, and ExpiredTokenError when the token is past its expiry time.
```

---

### Problem B: File Deletion API Has Multiple Context-Dependent Failure Modes

**Task Description:**
Write a **public-facing docstring** for `delete_user_file(path: str) -> str` that is safe for developers to rely on.
The summary must clearly state:

* what is returned on success,
* what happens on various failure conditions,
* the **security requirement** (owner permission),
* all distinct exceptions and when they occur.

**Starter Code:**

```python
# file_ops.py
import os
from pathlib import Path

class DiskFullError(Exception):
    pass

class NetworkMountError(Exception):
    pass

def delete_user_file(path: str) -> str:
    """
    TODO
    """
    p = Path(path)
    
    # Check if file exists
    if not p.exists():
        raise FileNotFoundError(f"File not found: {path}")
    
    # Check ownership (simplified)
    if p.stat().st_uid != os.getuid():
        raise PermissionError(f"Not owner of file: {path}")
    
    # Check if on network mount
    if str(p).startswith("/mnt/network/"):
        try:
            # Attempt network operation
            p.unlink()
        except OSError:
            raise NetworkMountError(f"Network mount unavailable: {path}")
    else:
        try:
            p.unlink()
        except OSError as e:
            if "No space left" in str(e):
                raise DiskFullError(f"Disk full during cleanup: {path}")
            raise OSError(f"IO error deleting file: {path}")
    
    return path
```

---

### Guidelines that didn't work for Problem B

#### Guideline 2: Explicitly Constrain Summary Length

**Description:**
Request summaries under a specific word count (e.g., "Summarize in one sentence, maximum 15 words") or match a target format like "@brief [one-line description]". This assists in preventing unnecessary summaries such as error handling, which explicitly instructing to ignore this can hurt results.

**Reasoning:**
LLMs tend to generate verbose summaries that score poorly on BLEU metrics despite being semantically accurate [3]. The Ericsson study found that a simple "WordRestrict" prompt asking for <20 words performed as well as complex retrieval-augmented approaches while being far simpler to implement [5].

**Prompt and Context:**

> "Generate a @brief description in one sentence (max 15 words) for `delete_user_file`."

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```text
@brief Deletes a user-owned file at the given path and returns the path.
```

**Why this is not correct/optimal for this counterexample:**

* It **omits all failure modes**: the function can raise 5 distinct exceptions (`FileNotFoundError`, `PermissionError`, `DiskFullError`, `OSError`, `NetworkMountError`) — none are mentioned.
* It **hides conditional behavior**: network-mounted files have different error handling than local files.
* It **does not mention severity**: `PermissionError` (security) and `NetworkMountError` (environment) have different implications for callers.
* For an API with multiple context-dependent failures, this brevity-only summary misleads callers into assuming deletion is simple and always succeeds or fails uniformly.

---

### New and Updated Guidelines that worked for Problem B

#### Guideline 2 (Updated): Constrain Length — Use Short, Structured Fields with Tiered Errors

**Description:**
Request brevity, but require a minimal set of short, explicit fields so critical information can't be squeezed out by an aggressive word limit. For functions with multiple failure modes, use tiered error fields (`@errors_high`, `@errors_other`) to communicate priority without losing completeness.

**Reasoning:**
Strict single-line word limits work for simple helpers but fail when a function has multiple distinct, observable failure modes. Using compact tagged fields with per-field limits keeps outputs short while guaranteeing coverage of critical information.

**Prompt and Context:**

> "Write a docstring for `delete_user_file` using these tagged fields. Keep each field within its word limit.
> @brief (one sentence, max 12 words)
> @effects (max 10 words — short phrase or 'none')
> @errors_high (critical errors, max 8 words)
> @errors_other (other errors, max 10 words)
> @security (max 10 words)
> Output exactly these tags in the given order."

**Solution or Output generated by GitHub Copilot (correct/optimal):**

```text
@brief Deletes a user-owned file; returns path on success.
@effects Removes file from disk permanently.
@errors_high FileNotFoundError, PermissionError.
@errors_other DiskFullError, OSError, NetworkMountError.
@security Requires caller to be file owner.
```

**Why this is correct/optimal for this counterexample:**

* **Complete failure coverage**: all 5 exceptions are listed, grouped by severity.
* **Security requirement stated**: ownership check is explicit.
* **Still concise**: each field respects word limits for quick scanning.
* **Actionable**: callers know which errors to handle as critical vs. environmental.

---