# Week X Feedback: Code Generation

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia


# Part 1

## 1. Counterexample Problems

### Problem A_1: Secure JWT Verification (Auth Middleware)

**Task Description:**
You are implementing an authentication middleware for a Flask API that accepts Bearer tokens (JWT). Implement:

```py
def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    """
    Returns the decoded JWT claims if valid.
    Raises ValueError with a clear message if invalid.
    """
```

Requirements:

* Accept header format: `"Bearer <token>"`
* Verify **signature**, **expiration**, **issuer**, and **audience**
* Reject tokens that use `"alg": "none"` or any algorithm other than RS256
* Return decoded claims as a dict on success

**Starter Code:**

```py
from __future__ import annotations

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    # TODO
    raise NotImplementedError
```



---

## 2. Guidelines that didn't work for Problem A_1

#### Guideline 3: Specify required external libraries/packages and their purpose

**Prompt and Context:**

> Implement `verify_bearer_token(auth_header, public_key_pem)`.
> Use **PyJWT** (`jwt` package) to decode and verify JWTs.
> Purpose: parse the token and validate it.
> Raise `ValueError` when invalid.
> Use started code from /Users/sofiiatkach/Desktop/LLM/846_Group/week6/resources/updated_guideline3/started_code.py

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```py
import jwt

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    token = auth_header.split(" ")[1]
    # decode token
    claims = jwt.decode(token, public_key_pem, algorithms=["RS256"], options={"verify_signature": True})
    return claims
```

**Why this is not fully correct:**
Even though the prompt followed Guideline 3 (named the library + general purpose), the output still misses critical security requirements:

* No validation for `"Bearer "` prefix or malformed headers (crashes / unclear errors).
* Does **not** enforce `audience` and `issuer`.
* Does not explicitly reject `alg=none` or unexpected header algorithms.
* No clear `ValueError` messages for different failure modes and I think without it it's hard to debug, risky to handle.

So I would say in this problem when I specifies library + purpose - it was not enough when the correct usage of the library is the real problem.

---

## 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 3 (Updated): When you name a library, also specify its **secure configuration** and forbid unsafe defaults

**Prompt and Context:**

> Implement `verify_bearer_token(auth_header, public_key_pem)`. Use **PyJWT**.
> You must explicitly enforce these security rules:
>
> 1. Header must start with `"Bearer "`, otherwise raise `ValueError("missing bearer token")`.
> 2. Allow **only** `algorithms=["RS256"]` and reject anything else (including `"none"`).
> 3. Require and verify `exp`, `iss`, and `aud` (issuer must equal `"https://auth.example.com"`, audience must equal `"api://my-service"`).
> 4. Catch PyJWT exceptions and re-raise as `ValueError` with a clear message - expired, bad signature, bad issuer/audience, malformed.
> Return claims dict on success.
> Use started code from /Users/sofiiatkach/Desktop/LLM/846_Group/week6/resources/updated_guideline3/started_code.py


**Solution or Output generated by GitHub Copilot (correct/optimal):**

```py
import jwt
from jwt import InvalidTokenError, ExpiredSignatureError, InvalidAudienceError, InvalidIssuerError

ISSUER = "https://auth.example.com"
AUDIENCE = "api://my-service"

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    if not auth_header or not auth_header.startswith("Bearer "):
        raise ValueError("missing bearer token")

    parts = auth_header.split(" ", 1)
    token = parts[1].strip()
    if not token:
        raise ValueError("missing bearer token")

    try:
        claims = jwt.decode(
            token,
            public_key_pem,
            algorithms=["RS256"],
            issuer=ISSUER,
            audience=AUDIENCE,
            options={
                "require": ["exp", "iss", "aud"],
            },
        )
        return claims
    except ExpiredSignatureError:
        raise ValueError("token expired")
    except (InvalidAudienceError, InvalidIssuerError):
        raise ValueError("invalid token claims")
    except InvalidTokenError:
        raise ValueError("invalid token")
```

I think this is better because the code explicitly checks the Bearer header format, issuer and audience instead of relying on library defaults. It also allows only RS256 and produces clear, consistent error messages so it’s less likely to accept a bad token or fail in confusing ways. Overall, it’s safer and easier to maintain and debug and I am happy with a result now.

---


# Part 2
## 1. Counterexample Problem

### Problem B: Mini Issue Tracker API (FastAPI)

You are given a small **FastAPI** service for an internal issue tracker. The codebase contains a **bug** and is missing basic API features. Your task is to fix the bug, extend the API, and make all tests pass.

Codebase: https://github.com/EZeJ/846_Group/tree/main/week6/resources/problem_B

**Tasks**

1. Fix the Bug
`GET /issues?status=open` must return **only open issues**.
The current status filter is incorrect.

2. Add Pagination & Sorting
Extend `GET /issues` with:

**Query parameters**
- `limit` (default 20, min 1, max 100)
- `offset` (default 0, min 0)
- `sort` ∈ {`created_at`, `priority`, `title`} (default `created_at`)
- `order` ∈ {`asc`, `desc`} (default `desc`)

**Rules**
- Apply sorting **before** pagination
- Existing filters (`status`, `q`) must keep working

3. Preserve Response Format
The API response **must not change shape**:
```json
{
  "items": [...],
  "total": 123,
  "limit": 20,
  "offset": 0
}
```

## 2. Guidelines that didn't work for Problem B

## Guideline 5 (“work in short iterative cycles”) 

This Guideline 5 encourages incremental progress, applying it directly to Problem B led to several issues during development.

1. Temporary spec violations

When pagination was first added, the `limit` parameter was defined with `ge=0`, even though the task required `limit ≥ 1`. This violation went unnoticed until a later validation step. The guideline encourages moving forward after each small change, which makes it easy to accept incorrect constraints temporarily and forget to revisit them.

```python
limit: int = Query(20, ge=0)
```
2. Review prompts focused on whether the code “worked” rather than checking global invariants. For example, early reviews did not explicitly verify that pagination constraints matched the specification or that ordering requirements would still hold once sorting was added. As a result, correctness was assumed rather than demonstrated.

3. Pagination was implemented before sorting. This created a structural risk that sorting would later be applied after pagination, which would violate the requirement that sorting occur first. The final solution avoided this only because sorting happened to be implemented in the service layer later, not because the guideline enforced the correct order.


## 3. New and Updated Guidelines that worked for Problem B

**Updated Guideline 5: Constraint-Aware Iteration**

Before making changes, briefly clarify the **constraints** of the task:

1. **State what relationships must be preserved**
   - For example: some steps must happen before others, or some values must be computed from the full result set.
   - You do not need to decide *how* this will be implemented yet.

2. **Clarify responsibility boundaries**
   - Decide which parts of the system are allowed to handle which kinds of logic.
   - This prevents later changes from spreading responsibilities unintentionally.

Then work in small, incremental steps.  
After each step, verify that the change **does not violate the stated constraints**, even if new features are added later.


The updated guideline worked better because it asked the model to pause and think about the rules of the task before changing the code. This made the fixes more focused and helped keep logic in the right place, instead of spreading changes across the codebase. As a result, each step was easier to review, and it was clearer whether a change respected the original requirements rather than just making the code “work.”


# Part 3
## 1. Counterexample Problem C
## 2. Guidelines that didn't work for Problem C
## 3. New and Updated Guidelines that worked for Problem C



# Part 4
## 1. Counterexample Problem D
## 2. Guidelines that didn't work for Problem D
## 3. New and Updated Guidelines that worked for Problem D


