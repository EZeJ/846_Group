# Week X Feedback: Code Generation

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia

## 1. Counterexample Problems

### Problem A_1: Secure JWT Verification (Auth Middleware)

**Task Description:**
You are implementing an authentication middleware for a Flask API that accepts Bearer tokens (JWT). Implement:

```py
def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    """
    Returns the decoded JWT claims if valid.
    Raises ValueError with a clear message if invalid.
    """
```

Requirements:

* Accept header format: `"Bearer <token>"`
* Verify **signature**, **expiration**, **issuer**, and **audience**
* Reject tokens that use `"alg": "none"` or any algorithm other than RS256
* Return decoded claims as a dict on success

**Starter Code:**

```py
from __future__ import annotations

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    # TODO
    raise NotImplementedError
```

---

## 2. Guidelines that didn't work for Problem A_1

#### Guideline 3: Specify required external libraries/packages and their purpose

**Prompt and Context:**

> Implement `verify_bearer_token(auth_header, public_key_pem)`.
> Use **PyJWT** (`jwt` package) to decode and verify JWTs.
> Purpose: parse the token and validate it.
> Raise `ValueError` when invalid.
> Use started code from /Users/sofiiatkach/Desktop/LLM/846_Group/week6/resources/updated_guideline3/started_code.py

**Solution or Output generated by GitHub Copilot (not correct/optimal):**

```py
import jwt

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    token = auth_header.split(" ")[1]
    # decode token
    claims = jwt.decode(token, public_key_pem, algorithms=["RS256"], options={"verify_signature": True})
    return claims
```

**Why this is not fully correct:**
Even though the prompt followed Guideline 3 (named the library + general purpose), the output still misses critical security requirements:

* No validation for `"Bearer "` prefix or malformed headers (crashes / unclear errors).
* Does **not** enforce `audience` and `issuer`.
* Does not explicitly reject `alg=none` or unexpected header algorithms.
* No clear `ValueError` messages for different failure modes and I think without it it's hard to debug, risky to handle.

So I would say in this problem when I specifies library + purpose - it was not enough when the correct usage of the library is the real problem.

---

## 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 3 (Updated): When you name a library, also specify its **secure configuration** and forbid unsafe defaults

**Prompt and Context:**

> Implement `verify_bearer_token(auth_header, public_key_pem)`. Use **PyJWT**.
> You must explicitly enforce these security rules:
>
> 1. Header must start with `"Bearer "`, otherwise raise `ValueError("missing bearer token")`.
> 2. Allow **only** `algorithms=["RS256"]` and reject anything else (including `"none"`).
> 3. Require and verify `exp`, `iss`, and `aud` (issuer must equal `"https://auth.example.com"`, audience must equal `"api://my-service"`).
> 4. Catch PyJWT exceptions and re-raise as `ValueError` with a clear message - expired, bad signature, bad issuer/audience, malformed.
> Return claims dict on success.
> Use started code from /Users/sofiiatkach/Desktop/LLM/846_Group/week6/resources/updated_guideline3/started_code.py


**Solution or Output generated by GitHub Copilot (correct/optimal):**

```py
import jwt
from jwt import InvalidTokenError, ExpiredSignatureError, InvalidAudienceError, InvalidIssuerError

ISSUER = "https://auth.example.com"
AUDIENCE = "api://my-service"

def verify_bearer_token(auth_header: str, public_key_pem: str) -> dict:
    if not auth_header or not auth_header.startswith("Bearer "):
        raise ValueError("missing bearer token")

    parts = auth_header.split(" ", 1)
    token = parts[1].strip()
    if not token:
        raise ValueError("missing bearer token")

    try:
        claims = jwt.decode(
            token,
            public_key_pem,
            algorithms=["RS256"],
            issuer=ISSUER,
            audience=AUDIENCE,
            options={
                "require": ["exp", "iss", "aud"],
            },
        )
        return claims
    except ExpiredSignatureError:
        raise ValueError("token expired")
    except (InvalidAudienceError, InvalidIssuerError):
        raise ValueError("invalid token claims")
    except InvalidTokenError:
        raise ValueError("invalid token")
```

I think this is better because the code explicitly checks the Bearer header format, issuer and audience instead of relying on library defaults. It also allows only RS256 and produces clear, consistent error messages so it’s less likely to accept a bad token or fail in confusing ways. Overall, it’s safer and easier to maintain and debug and I am happy with a result now.

---
