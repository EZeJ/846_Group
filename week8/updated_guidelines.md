# Week X Feedback: Debugging

**Authors:** Liliana Hotsko, Alina Lytovchenko, Sofiia Tkach, Zesheng(Ethan) Jia


# Part 1

## 1. Counterexample Problems


### Problem A: Race condition in concurrent balance updates (Python)

**Task Description:**  
You are given a simple `Account` class with a `deposit()` method. When multiple threads call `deposit()` at the same time, the final balance is sometimes lower than expected (due to a **non-atomic read–modify–write).

Your goal is to fix the bug so the included test passes reliably under concurrency.

**Starter Code:**  
- /Users/sofiiatkach/Desktop/LLM/846_Group/week8/resources/updated_guideline_2/sum_async.py 

---

### 2. Guidelines that didn't fully work for Problem A

#### Guideline 2 Self Debugging

This guideline says to ask the LLM to do **(1) Generation → (2) Explanation → (3) Feedback** to debug the code.

**Prompt and Context (applies the guideline, but still fails on this problem):**  

> I have a Python function that sometimes produces the wrong final value in a concurrency test.  
> Please debug the code in `account.py` and make the test in `test_account.py` pass.  
> Ensure to follow these steps:  
> 1) Generation: Given the problem description, predict candidate solutions.  
> 2) Explanation: Explain your predictions and reason through a sample execution trace.  
> 3) Feedback: Generate a feedback message based on correctness of your prediction results.  

**Solution or Output generated by GitHub Copilot:**  

```

### **Candidate Fix #1**

“This issue appears to be caused by `time.sleep()` inside `deposit()`. The sleep introduces unnecessary delay between reading and writing the balance, increasing the likelihood of inconsistent intermediate states. Removing the sleep should make updates more consistent and eliminate the flaky behavior.”

### **Candidate Fix #2**

“If the problem persists, consider slightly reducing concurrency in the test or adding a small delay after thread creation to ensure threads complete in a predictable order. Logging may also help confirm execution flow.”

---

### **Proposed Code Change (account.py)**

python
def deposit(self, amount: int) -> None:
    # Removed artificial delay causing timing inconsistencies
    # time.sleep(0.0001)
    self._balance += amount


---

### **Explanation (Generation + Execution Trace Reasoning)**

“Consider two threads, T1 and T2.

1. T1 reads `_balance = 0`
2. T1 sleeps
3. T2 reads `_balance = 0`
4. T2 writes `_balance = 1`
5. T1 resumes and writes `_balance = 1`

This overlap can cause lost updates. Since `time.sleep()` widens this timing window, removing it reduces the chance of interleaving.

Additionally, CPython uses the Global Interpreter Lock (GIL), which ensures that bytecode execution is serialized. Because integer operations are relatively small and executed quickly, removing the artificial delay should make the increment effectively safe in practice.”

```
**Why this is not fully correct:**  
Removing sleep() may hide the bug, but it doesn’t fix it. balance += amount is still not atomic, so threads can still lose updates. The bug is nondeterministic and a trace explanation without real tests can be misleading.

---

### 3. Updated Guideline: For nondeterministic/concurrent bugs, require empirical evidence + a deterministic reproducer

**What to do instead (updated rule):**
1. Do not accept trace-onl” reasoning for concurrency/nondeterministic failures.  
2. First, request or create a minimal reproducer and/or add logging that captures interleavings.  
3. Ask the model to propose a fix that uses an appropriate synchronization primitive (e.g., `threading.Lock`) or a safe atomic abstraction and then re-run the reproducer.

**Prompt and Context:**  

> You are debugging a nondeterministic concurrency bug.  
> Files: `account.py`, `test_account.py`.  
> Step 1: Identify whether this is a data race or another concurrency hazard, and explain why.  
> Step 2: Propose a **minimal, correct fix** using Python synchronization primitives (no sleeps/retries/timeouts).  
> Step 3: Update `account.py` only, and keep the public API unchanged.  
> Step 4: Explain how your fix prevents lost updates in *all* thread interleavings.  
> Constraint: correctness over “making the test pass”; keep edge cases in mind (e.g., many threads, many operations).

**Solution or Output generated by GitHub Copilot (correct direction):**  

```
### **Step 1: Identify the issue**

This is a **data race**.
The operation `self._balance += amount` is a read–modify–write sequence:

1. Read current balance
2. Compute new value
3. Write updated balance

If two threads execute this sequence at the same time, one update can overwrite the other, causing lost increments. Since there is no synchronization protecting `_balance`, this is a classic race condition.

---

### **Step 2: Minimal Correct Fix**

Use a `threading.Lock` to protect the critical section so that only one thread can update `_balance` at a time.

---

### **Updated `account.py`**

python
import threading

class Account:
    def __init__(self):
        self._balance = 0
        self._lock = threading.Lock()

    def deposit(self, amount: int) -> None:
        with self._lock:
            self._balance += amount

    def get_balance(self) -> int:
        return self._balance

---

### **Step 3: Why This Fix Is Correct**

The lock ensures that the entire read–modify–write sequence executes atomically with respect to other threads.

No two threads can enter the `deposit()` critical section simultaneously, so:

* No interleaving can cause lost updates.
* The fix works for any number of threads.
* It does not rely on timing, sleeps, retries, or CPython-specific behavior.
* The public API remains unchanged.

This guarantees correctness for all thread interleavings, not just the ones observed during testing.

```

I would say the updated guideline is better because it forces you to prove the bug first and then fix it correctly with a lock. It avoids “fixes” like removing sleep() that only hide the problem and make the test pass by luck.

---



# Part 2

## 1. Counterexample Problems

### Problem A_1: [Title]

**Task Description:**  
Describe the task clearly and precisely.

**Starter Code:**  
// Include all necessary starter code here or in a repo and share the link here.

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is not the correct/optimal answer. 

...

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is the correct/optimal answer. 

...

---


# Part 3

## 1. Counterexample Problems

### Problem A_1: [Title]

**Task Description:**  
Describe the task clearly and precisely.

**Starter Code:**  
// Include all necessary starter code here or in a repo and share the link here.

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is not the correct/optimal answer. 

...

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is the correct/optimal answer. 

...

---


# Part 4

## 1. Counterexample Problems

### Problem A_1: [Title]

**Task Description:**  
Describe the task clearly and precisely.

**Starter Code:**  
// Include all necessary starter code here or in a repo and share the link here.

---

### 2. Guidelines that didn't work for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is not the correct/optimal answer. 

...

---

### 3. New and Updated Guidelines that worked for Problem A_1

#### Guideline 1: [Title]
**Prompt and Context:**  
State the prompt and context that you gave to GitHub Copilot to implement that guideline. 

**Solution or Output generated by GitHub Copilot:**  
Give the answer here generated by GitHub Copilot for the counterexaple that you think is the correct/optimal answer. 

...

---
